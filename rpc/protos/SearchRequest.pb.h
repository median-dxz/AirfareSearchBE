// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SearchRequest.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SearchRequest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SearchRequest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SearchRequest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SearchRequest_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SearchRequest_2eproto;
namespace AirfareSearch {
class City;
struct CityDefaultTypeInternal;
extern CityDefaultTypeInternal _City_default_instance_;
class Flight;
struct FlightDefaultTypeInternal;
extern FlightDefaultTypeInternal _Flight_default_instance_;
class FlightResult;
struct FlightResultDefaultTypeInternal;
extern FlightResultDefaultTypeInternal _FlightResult_default_instance_;
class SearchRequest;
struct SearchRequestDefaultTypeInternal;
extern SearchRequestDefaultTypeInternal _SearchRequest_default_instance_;
class SearchResponse;
struct SearchResponseDefaultTypeInternal;
extern SearchResponseDefaultTypeInternal _SearchResponse_default_instance_;
class SearchRoute;
struct SearchRouteDefaultTypeInternal;
extern SearchRouteDefaultTypeInternal _SearchRoute_default_instance_;
}  // namespace AirfareSearch
PROTOBUF_NAMESPACE_OPEN
template<> ::AirfareSearch::City* Arena::CreateMaybeMessage<::AirfareSearch::City>(Arena*);
template<> ::AirfareSearch::Flight* Arena::CreateMaybeMessage<::AirfareSearch::Flight>(Arena*);
template<> ::AirfareSearch::FlightResult* Arena::CreateMaybeMessage<::AirfareSearch::FlightResult>(Arena*);
template<> ::AirfareSearch::SearchRequest* Arena::CreateMaybeMessage<::AirfareSearch::SearchRequest>(Arena*);
template<> ::AirfareSearch::SearchResponse* Arena::CreateMaybeMessage<::AirfareSearch::SearchResponse>(Arena*);
template<> ::AirfareSearch::SearchRoute* Arena::CreateMaybeMessage<::AirfareSearch::SearchRoute>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace AirfareSearch {

enum Cabin : int {
  F = 0,
  C = 1,
  Y = 2,
  Cabin_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Cabin_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Cabin_IsValid(int value);
constexpr Cabin Cabin_MIN = F;
constexpr Cabin Cabin_MAX = Y;
constexpr int Cabin_ARRAYSIZE = Cabin_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Cabin_descriptor();
template<typename T>
inline const std::string& Cabin_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Cabin>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Cabin_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Cabin_descriptor(), enum_t_value);
}
inline bool Cabin_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Cabin* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Cabin>(
    Cabin_descriptor(), name, value);
}
// ===================================================================

class City final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.City) */ {
 public:
  inline City() : City(nullptr) {}
  ~City() override;
  explicit PROTOBUF_CONSTEXPR City(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  City(const City& from);
  City(City&& from) noexcept
    : City() {
    *this = ::std::move(from);
  }

  inline City& operator=(const City& from) {
    CopyFrom(from);
    return *this;
  }
  inline City& operator=(City&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const City& default_instance() {
    return *internal_default_instance();
  }
  static inline const City* internal_default_instance() {
    return reinterpret_cast<const City*>(
               &_City_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(City& a, City& b) {
    a.Swap(&b);
  }
  inline void Swap(City* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(City* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  City* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<City>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const City& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const City& from) {
    City::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(City* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.City";
  }
  protected:
  explicit City(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string code = 2;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // @@protoc_insertion_point(class_scope:AirfareSearch.City)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// -------------------------------------------------------------------

class Flight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.Flight) */ {
 public:
  inline Flight() : Flight(nullptr) {}
  ~Flight() override;
  explicit PROTOBUF_CONSTEXPR Flight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Flight(const Flight& from);
  Flight(Flight&& from) noexcept
    : Flight() {
    *this = ::std::move(from);
  }

  inline Flight& operator=(const Flight& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flight& operator=(Flight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Flight& default_instance() {
    return *internal_default_instance();
  }
  static inline const Flight* internal_default_instance() {
    return reinterpret_cast<const Flight*>(
               &_Flight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Flight& a, Flight& b) {
    a.Swap(&b);
  }
  inline void Swap(Flight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Flight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Flight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Flight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Flight& from) {
    Flight::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.Flight";
  }
  protected:
  explicit Flight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCabinsFieldNumber = 7,
    kCarrierFieldNumber = 1,
    kFlightNoFieldNumber = 2,
    kDepartureDatetimeFieldNumber = 5,
    kArrivalDatetimeFieldNumber = 6,
    kDepartureFieldNumber = 3,
    kArrivalFieldNumber = 4,
  };
  // repeated .AirfareSearch.Cabin cabins = 7;
  int cabins_size() const;
  private:
  int _internal_cabins_size() const;
  public:
  void clear_cabins();
  private:
  ::AirfareSearch::Cabin _internal_cabins(int index) const;
  void _internal_add_cabins(::AirfareSearch::Cabin value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_cabins();
  public:
  ::AirfareSearch::Cabin cabins(int index) const;
  void set_cabins(int index, ::AirfareSearch::Cabin value);
  void add_cabins(::AirfareSearch::Cabin value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& cabins() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_cabins();

  // string carrier = 1;
  void clear_carrier();
  const std::string& carrier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_carrier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_carrier();
  PROTOBUF_NODISCARD std::string* release_carrier();
  void set_allocated_carrier(std::string* carrier);
  private:
  const std::string& _internal_carrier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_carrier(const std::string& value);
  std::string* _internal_mutable_carrier();
  public:

  // string flightNo = 2;
  void clear_flightno();
  const std::string& flightno() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flightno(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flightno();
  PROTOBUF_NODISCARD std::string* release_flightno();
  void set_allocated_flightno(std::string* flightno);
  private:
  const std::string& _internal_flightno() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flightno(const std::string& value);
  std::string* _internal_mutable_flightno();
  public:

  // string departureDatetime = 5;
  void clear_departuredatetime();
  const std::string& departuredatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_departuredatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_departuredatetime();
  PROTOBUF_NODISCARD std::string* release_departuredatetime();
  void set_allocated_departuredatetime(std::string* departuredatetime);
  private:
  const std::string& _internal_departuredatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_departuredatetime(const std::string& value);
  std::string* _internal_mutable_departuredatetime();
  public:

  // string arrivalDatetime = 6;
  void clear_arrivaldatetime();
  const std::string& arrivaldatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arrivaldatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arrivaldatetime();
  PROTOBUF_NODISCARD std::string* release_arrivaldatetime();
  void set_allocated_arrivaldatetime(std::string* arrivaldatetime);
  private:
  const std::string& _internal_arrivaldatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arrivaldatetime(const std::string& value);
  std::string* _internal_mutable_arrivaldatetime();
  public:

  // .AirfareSearch.City departure = 3;
  bool has_departure() const;
  private:
  bool _internal_has_departure() const;
  public:
  void clear_departure();
  const ::AirfareSearch::City& departure() const;
  PROTOBUF_NODISCARD ::AirfareSearch::City* release_departure();
  ::AirfareSearch::City* mutable_departure();
  void set_allocated_departure(::AirfareSearch::City* departure);
  private:
  const ::AirfareSearch::City& _internal_departure() const;
  ::AirfareSearch::City* _internal_mutable_departure();
  public:
  void unsafe_arena_set_allocated_departure(
      ::AirfareSearch::City* departure);
  ::AirfareSearch::City* unsafe_arena_release_departure();

  // .AirfareSearch.City arrival = 4;
  bool has_arrival() const;
  private:
  bool _internal_has_arrival() const;
  public:
  void clear_arrival();
  const ::AirfareSearch::City& arrival() const;
  PROTOBUF_NODISCARD ::AirfareSearch::City* release_arrival();
  ::AirfareSearch::City* mutable_arrival();
  void set_allocated_arrival(::AirfareSearch::City* arrival);
  private:
  const ::AirfareSearch::City& _internal_arrival() const;
  ::AirfareSearch::City* _internal_mutable_arrival();
  public:
  void unsafe_arena_set_allocated_arrival(
      ::AirfareSearch::City* arrival);
  ::AirfareSearch::City* unsafe_arena_release_arrival();

  // @@protoc_insertion_point(class_scope:AirfareSearch.Flight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> cabins_;
    mutable std::atomic<int> _cabins_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr carrier_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flightno_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr departuredatetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arrivaldatetime_;
    ::AirfareSearch::City* departure_;
    ::AirfareSearch::City* arrival_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// -------------------------------------------------------------------

class FlightResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.FlightResult) */ {
 public:
  inline FlightResult() : FlightResult(nullptr) {}
  ~FlightResult() override;
  explicit PROTOBUF_CONSTEXPR FlightResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlightResult(const FlightResult& from);
  FlightResult(FlightResult&& from) noexcept
    : FlightResult() {
    *this = ::std::move(from);
  }

  inline FlightResult& operator=(const FlightResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlightResult& operator=(FlightResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlightResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlightResult* internal_default_instance() {
    return reinterpret_cast<const FlightResult*>(
               &_FlightResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FlightResult& a, FlightResult& b) {
    a.Swap(&b);
  }
  inline void Swap(FlightResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlightResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlightResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlightResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlightResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FlightResult& from) {
    FlightResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlightResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.FlightResult";
  }
  protected:
  explicit FlightResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlightsFieldNumber = 1,
    kAgenciesFieldNumber = 3,
    kPriceFieldNumber = 2,
  };
  // repeated .AirfareSearch.Flight flights = 1;
  int flights_size() const;
  private:
  int _internal_flights_size() const;
  public:
  void clear_flights();
  ::AirfareSearch::Flight* mutable_flights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::Flight >*
      mutable_flights();
  private:
  const ::AirfareSearch::Flight& _internal_flights(int index) const;
  ::AirfareSearch::Flight* _internal_add_flights();
  public:
  const ::AirfareSearch::Flight& flights(int index) const;
  ::AirfareSearch::Flight* add_flights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::Flight >&
      flights() const;

  // repeated string agencies = 3;
  int agencies_size() const;
  private:
  int _internal_agencies_size() const;
  public:
  void clear_agencies();
  const std::string& agencies(int index) const;
  std::string* mutable_agencies(int index);
  void set_agencies(int index, const std::string& value);
  void set_agencies(int index, std::string&& value);
  void set_agencies(int index, const char* value);
  void set_agencies(int index, const char* value, size_t size);
  std::string* add_agencies();
  void add_agencies(const std::string& value);
  void add_agencies(std::string&& value);
  void add_agencies(const char* value);
  void add_agencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& agencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_agencies();
  private:
  const std::string& _internal_agencies(int index) const;
  std::string* _internal_add_agencies();
  public:

  // int32 price = 2;
  void clear_price();
  int32_t price() const;
  void set_price(int32_t value);
  private:
  int32_t _internal_price() const;
  void _internal_set_price(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AirfareSearch.FlightResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::Flight > flights_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> agencies_;
    int32_t price_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// -------------------------------------------------------------------

class SearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.SearchResponse) */ {
 public:
  inline SearchResponse() : SearchResponse(nullptr) {}
  ~SearchResponse() override;
  explicit PROTOBUF_CONSTEXPR SearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchResponse(const SearchResponse& from);
  SearchResponse(SearchResponse&& from) noexcept
    : SearchResponse() {
    *this = ::std::move(from);
  }

  inline SearchResponse& operator=(const SearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchResponse& operator=(SearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchResponse* internal_default_instance() {
    return reinterpret_cast<const SearchResponse*>(
               &_SearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SearchResponse& a, SearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchResponse& from) {
    SearchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.SearchResponse";
  }
  protected:
  explicit SearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .AirfareSearch.FlightResult data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::AirfareSearch::FlightResult* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::FlightResult >*
      mutable_data();
  private:
  const ::AirfareSearch::FlightResult& _internal_data(int index) const;
  ::AirfareSearch::FlightResult* _internal_add_data();
  public:
  const ::AirfareSearch::FlightResult& data(int index) const;
  ::AirfareSearch::FlightResult* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::FlightResult >&
      data() const;

  // @@protoc_insertion_point(class_scope:AirfareSearch.SearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::FlightResult > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// -------------------------------------------------------------------

class SearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.SearchRequest) */ {
 public:
  inline SearchRequest() : SearchRequest(nullptr) {}
  ~SearchRequest() override;
  explicit PROTOBUF_CONSTEXPR SearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchRequest(const SearchRequest& from);
  SearchRequest(SearchRequest&& from) noexcept
    : SearchRequest() {
    *this = ::std::move(from);
  }

  inline SearchRequest& operator=(const SearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRequest& operator=(SearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRequest* internal_default_instance() {
    return reinterpret_cast<const SearchRequest*>(
               &_SearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SearchRequest& a, SearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchRequest& from) {
    SearchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.SearchRequest";
  }
  protected:
  explicit SearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgenciesFieldNumber = 3,
    kRoutesFieldNumber = 4,
    kPeopleFieldNumber = 1,
    kMaxResultsFieldNumber = 2,
  };
  // repeated string agencies = 3;
  int agencies_size() const;
  private:
  int _internal_agencies_size() const;
  public:
  void clear_agencies();
  const std::string& agencies(int index) const;
  std::string* mutable_agencies(int index);
  void set_agencies(int index, const std::string& value);
  void set_agencies(int index, std::string&& value);
  void set_agencies(int index, const char* value);
  void set_agencies(int index, const char* value, size_t size);
  std::string* add_agencies();
  void add_agencies(const std::string& value);
  void add_agencies(std::string&& value);
  void add_agencies(const char* value);
  void add_agencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& agencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_agencies();
  private:
  const std::string& _internal_agencies(int index) const;
  std::string* _internal_add_agencies();
  public:

  // repeated .AirfareSearch.SearchRoute routes = 4;
  int routes_size() const;
  private:
  int _internal_routes_size() const;
  public:
  void clear_routes();
  ::AirfareSearch::SearchRoute* mutable_routes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::SearchRoute >*
      mutable_routes();
  private:
  const ::AirfareSearch::SearchRoute& _internal_routes(int index) const;
  ::AirfareSearch::SearchRoute* _internal_add_routes();
  public:
  const ::AirfareSearch::SearchRoute& routes(int index) const;
  ::AirfareSearch::SearchRoute* add_routes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::SearchRoute >&
      routes() const;

  // int32 people = 1;
  void clear_people();
  int32_t people() const;
  void set_people(int32_t value);
  private:
  int32_t _internal_people() const;
  void _internal_set_people(int32_t value);
  public:

  // int32 maxResults = 2;
  void clear_maxresults();
  int32_t maxresults() const;
  void set_maxresults(int32_t value);
  private:
  int32_t _internal_maxresults() const;
  void _internal_set_maxresults(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AirfareSearch.SearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> agencies_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::SearchRoute > routes_;
    int32_t people_;
    int32_t maxresults_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// -------------------------------------------------------------------

class SearchRoute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AirfareSearch.SearchRoute) */ {
 public:
  inline SearchRoute() : SearchRoute(nullptr) {}
  ~SearchRoute() override;
  explicit PROTOBUF_CONSTEXPR SearchRoute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchRoute(const SearchRoute& from);
  SearchRoute(SearchRoute&& from) noexcept
    : SearchRoute() {
    *this = ::std::move(from);
  }

  inline SearchRoute& operator=(const SearchRoute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchRoute& operator=(SearchRoute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchRoute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchRoute* internal_default_instance() {
    return reinterpret_cast<const SearchRoute*>(
               &_SearchRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SearchRoute& a, SearchRoute& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchRoute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchRoute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchRoute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchRoute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchRoute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SearchRoute& from) {
    SearchRoute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRoute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AirfareSearch.SearchRoute";
  }
  protected:
  explicit SearchRoute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepartureDateFieldNumber = 4,
    kDepartureFieldNumber = 2,
    kArrivalFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // string departureDate = 4;
  void clear_departuredate();
  const std::string& departuredate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_departuredate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_departuredate();
  PROTOBUF_NODISCARD std::string* release_departuredate();
  void set_allocated_departuredate(std::string* departuredate);
  private:
  const std::string& _internal_departuredate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_departuredate(const std::string& value);
  std::string* _internal_mutable_departuredate();
  public:

  // .AirfareSearch.City departure = 2;
  bool has_departure() const;
  private:
  bool _internal_has_departure() const;
  public:
  void clear_departure();
  const ::AirfareSearch::City& departure() const;
  PROTOBUF_NODISCARD ::AirfareSearch::City* release_departure();
  ::AirfareSearch::City* mutable_departure();
  void set_allocated_departure(::AirfareSearch::City* departure);
  private:
  const ::AirfareSearch::City& _internal_departure() const;
  ::AirfareSearch::City* _internal_mutable_departure();
  public:
  void unsafe_arena_set_allocated_departure(
      ::AirfareSearch::City* departure);
  ::AirfareSearch::City* unsafe_arena_release_departure();

  // .AirfareSearch.City arrival = 3;
  bool has_arrival() const;
  private:
  bool _internal_has_arrival() const;
  public:
  void clear_arrival();
  const ::AirfareSearch::City& arrival() const;
  PROTOBUF_NODISCARD ::AirfareSearch::City* release_arrival();
  ::AirfareSearch::City* mutable_arrival();
  void set_allocated_arrival(::AirfareSearch::City* arrival);
  private:
  const ::AirfareSearch::City& _internal_arrival() const;
  ::AirfareSearch::City* _internal_mutable_arrival();
  public:
  void unsafe_arena_set_allocated_arrival(
      ::AirfareSearch::City* arrival);
  ::AirfareSearch::City* unsafe_arena_release_arrival();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AirfareSearch.SearchRoute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr departuredate_;
    ::AirfareSearch::City* departure_;
    ::AirfareSearch::City* arrival_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SearchRequest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// City

// string name = 1;
inline void City::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& City::name() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.City.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void City::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.City.name)
}
inline std::string* City::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.City.name)
  return _s;
}
inline const std::string& City::_internal_name() const {
  return _impl_.name_.Get();
}
inline void City::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* City::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* City::release_name() {
  // @@protoc_insertion_point(field_release:AirfareSearch.City.name)
  return _impl_.name_.Release();
}
inline void City::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.City.name)
}

// string code = 2;
inline void City::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& City::code() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.City.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void City::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.City.code)
}
inline std::string* City::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.City.code)
  return _s;
}
inline const std::string& City::_internal_code() const {
  return _impl_.code_.Get();
}
inline void City::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* City::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* City::release_code() {
  // @@protoc_insertion_point(field_release:AirfareSearch.City.code)
  return _impl_.code_.Release();
}
inline void City::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.City.code)
}

// -------------------------------------------------------------------

// Flight

// string carrier = 1;
inline void Flight::clear_carrier() {
  _impl_.carrier_.ClearToEmpty();
}
inline const std::string& Flight::carrier() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.carrier)
  return _internal_carrier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flight::set_carrier(ArgT0&& arg0, ArgT... args) {
 
 _impl_.carrier_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.Flight.carrier)
}
inline std::string* Flight::mutable_carrier() {
  std::string* _s = _internal_mutable_carrier();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.carrier)
  return _s;
}
inline const std::string& Flight::_internal_carrier() const {
  return _impl_.carrier_.Get();
}
inline void Flight::_internal_set_carrier(const std::string& value) {
  
  _impl_.carrier_.Set(value, GetArenaForAllocation());
}
inline std::string* Flight::_internal_mutable_carrier() {
  
  return _impl_.carrier_.Mutable(GetArenaForAllocation());
}
inline std::string* Flight::release_carrier() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.carrier)
  return _impl_.carrier_.Release();
}
inline void Flight::set_allocated_carrier(std::string* carrier) {
  if (carrier != nullptr) {
    
  } else {
    
  }
  _impl_.carrier_.SetAllocated(carrier, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.carrier_.IsDefault()) {
    _impl_.carrier_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.carrier)
}

// string flightNo = 2;
inline void Flight::clear_flightno() {
  _impl_.flightno_.ClearToEmpty();
}
inline const std::string& Flight::flightno() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.flightNo)
  return _internal_flightno();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flight::set_flightno(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flightno_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.Flight.flightNo)
}
inline std::string* Flight::mutable_flightno() {
  std::string* _s = _internal_mutable_flightno();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.flightNo)
  return _s;
}
inline const std::string& Flight::_internal_flightno() const {
  return _impl_.flightno_.Get();
}
inline void Flight::_internal_set_flightno(const std::string& value) {
  
  _impl_.flightno_.Set(value, GetArenaForAllocation());
}
inline std::string* Flight::_internal_mutable_flightno() {
  
  return _impl_.flightno_.Mutable(GetArenaForAllocation());
}
inline std::string* Flight::release_flightno() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.flightNo)
  return _impl_.flightno_.Release();
}
inline void Flight::set_allocated_flightno(std::string* flightno) {
  if (flightno != nullptr) {
    
  } else {
    
  }
  _impl_.flightno_.SetAllocated(flightno, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flightno_.IsDefault()) {
    _impl_.flightno_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.flightNo)
}

// .AirfareSearch.City departure = 3;
inline bool Flight::_internal_has_departure() const {
  return this != internal_default_instance() && _impl_.departure_ != nullptr;
}
inline bool Flight::has_departure() const {
  return _internal_has_departure();
}
inline void Flight::clear_departure() {
  if (GetArenaForAllocation() == nullptr && _impl_.departure_ != nullptr) {
    delete _impl_.departure_;
  }
  _impl_.departure_ = nullptr;
}
inline const ::AirfareSearch::City& Flight::_internal_departure() const {
  const ::AirfareSearch::City* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::AirfareSearch::City&>(
      ::AirfareSearch::_City_default_instance_);
}
inline const ::AirfareSearch::City& Flight::departure() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.departure)
  return _internal_departure();
}
inline void Flight::unsafe_arena_set_allocated_departure(
    ::AirfareSearch::City* departure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = departure;
  if (departure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AirfareSearch.Flight.departure)
}
inline ::AirfareSearch::City* Flight::release_departure() {
  
  ::AirfareSearch::City* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AirfareSearch::City* Flight::unsafe_arena_release_departure() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.departure)
  
  ::AirfareSearch::City* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::AirfareSearch::City* Flight::_internal_mutable_departure() {
  
  if (_impl_.departure_ == nullptr) {
    auto* p = CreateMaybeMessage<::AirfareSearch::City>(GetArenaForAllocation());
    _impl_.departure_ = p;
  }
  return _impl_.departure_;
}
inline ::AirfareSearch::City* Flight::mutable_departure() {
  ::AirfareSearch::City* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.departure)
  return _msg;
}
inline void Flight::set_allocated_departure(::AirfareSearch::City* departure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.departure_;
  }
  if (departure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(departure);
    if (message_arena != submessage_arena) {
      departure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_ = departure;
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.departure)
}

// .AirfareSearch.City arrival = 4;
inline bool Flight::_internal_has_arrival() const {
  return this != internal_default_instance() && _impl_.arrival_ != nullptr;
}
inline bool Flight::has_arrival() const {
  return _internal_has_arrival();
}
inline void Flight::clear_arrival() {
  if (GetArenaForAllocation() == nullptr && _impl_.arrival_ != nullptr) {
    delete _impl_.arrival_;
  }
  _impl_.arrival_ = nullptr;
}
inline const ::AirfareSearch::City& Flight::_internal_arrival() const {
  const ::AirfareSearch::City* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::AirfareSearch::City&>(
      ::AirfareSearch::_City_default_instance_);
}
inline const ::AirfareSearch::City& Flight::arrival() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.arrival)
  return _internal_arrival();
}
inline void Flight::unsafe_arena_set_allocated_arrival(
    ::AirfareSearch::City* arrival) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = arrival;
  if (arrival) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AirfareSearch.Flight.arrival)
}
inline ::AirfareSearch::City* Flight::release_arrival() {
  
  ::AirfareSearch::City* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AirfareSearch::City* Flight::unsafe_arena_release_arrival() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.arrival)
  
  ::AirfareSearch::City* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::AirfareSearch::City* Flight::_internal_mutable_arrival() {
  
  if (_impl_.arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::AirfareSearch::City>(GetArenaForAllocation());
    _impl_.arrival_ = p;
  }
  return _impl_.arrival_;
}
inline ::AirfareSearch::City* Flight::mutable_arrival() {
  ::AirfareSearch::City* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.arrival)
  return _msg;
}
inline void Flight::set_allocated_arrival(::AirfareSearch::City* arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_;
  }
  if (arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival);
    if (message_arena != submessage_arena) {
      arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_ = arrival;
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.arrival)
}

// string departureDatetime = 5;
inline void Flight::clear_departuredatetime() {
  _impl_.departuredatetime_.ClearToEmpty();
}
inline const std::string& Flight::departuredatetime() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.departureDatetime)
  return _internal_departuredatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flight::set_departuredatetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.departuredatetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.Flight.departureDatetime)
}
inline std::string* Flight::mutable_departuredatetime() {
  std::string* _s = _internal_mutable_departuredatetime();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.departureDatetime)
  return _s;
}
inline const std::string& Flight::_internal_departuredatetime() const {
  return _impl_.departuredatetime_.Get();
}
inline void Flight::_internal_set_departuredatetime(const std::string& value) {
  
  _impl_.departuredatetime_.Set(value, GetArenaForAllocation());
}
inline std::string* Flight::_internal_mutable_departuredatetime() {
  
  return _impl_.departuredatetime_.Mutable(GetArenaForAllocation());
}
inline std::string* Flight::release_departuredatetime() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.departureDatetime)
  return _impl_.departuredatetime_.Release();
}
inline void Flight::set_allocated_departuredatetime(std::string* departuredatetime) {
  if (departuredatetime != nullptr) {
    
  } else {
    
  }
  _impl_.departuredatetime_.SetAllocated(departuredatetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.departuredatetime_.IsDefault()) {
    _impl_.departuredatetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.departureDatetime)
}

// string arrivalDatetime = 6;
inline void Flight::clear_arrivaldatetime() {
  _impl_.arrivaldatetime_.ClearToEmpty();
}
inline const std::string& Flight::arrivaldatetime() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.arrivalDatetime)
  return _internal_arrivaldatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Flight::set_arrivaldatetime(ArgT0&& arg0, ArgT... args) {
 
 _impl_.arrivaldatetime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.Flight.arrivalDatetime)
}
inline std::string* Flight::mutable_arrivaldatetime() {
  std::string* _s = _internal_mutable_arrivaldatetime();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.Flight.arrivalDatetime)
  return _s;
}
inline const std::string& Flight::_internal_arrivaldatetime() const {
  return _impl_.arrivaldatetime_.Get();
}
inline void Flight::_internal_set_arrivaldatetime(const std::string& value) {
  
  _impl_.arrivaldatetime_.Set(value, GetArenaForAllocation());
}
inline std::string* Flight::_internal_mutable_arrivaldatetime() {
  
  return _impl_.arrivaldatetime_.Mutable(GetArenaForAllocation());
}
inline std::string* Flight::release_arrivaldatetime() {
  // @@protoc_insertion_point(field_release:AirfareSearch.Flight.arrivalDatetime)
  return _impl_.arrivaldatetime_.Release();
}
inline void Flight::set_allocated_arrivaldatetime(std::string* arrivaldatetime) {
  if (arrivaldatetime != nullptr) {
    
  } else {
    
  }
  _impl_.arrivaldatetime_.SetAllocated(arrivaldatetime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.arrivaldatetime_.IsDefault()) {
    _impl_.arrivaldatetime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.Flight.arrivalDatetime)
}

// repeated .AirfareSearch.Cabin cabins = 7;
inline int Flight::_internal_cabins_size() const {
  return _impl_.cabins_.size();
}
inline int Flight::cabins_size() const {
  return _internal_cabins_size();
}
inline void Flight::clear_cabins() {
  _impl_.cabins_.Clear();
}
inline ::AirfareSearch::Cabin Flight::_internal_cabins(int index) const {
  return static_cast< ::AirfareSearch::Cabin >(_impl_.cabins_.Get(index));
}
inline ::AirfareSearch::Cabin Flight::cabins(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.Flight.cabins)
  return _internal_cabins(index);
}
inline void Flight::set_cabins(int index, ::AirfareSearch::Cabin value) {
  _impl_.cabins_.Set(index, value);
  // @@protoc_insertion_point(field_set:AirfareSearch.Flight.cabins)
}
inline void Flight::_internal_add_cabins(::AirfareSearch::Cabin value) {
  _impl_.cabins_.Add(value);
}
inline void Flight::add_cabins(::AirfareSearch::Cabin value) {
  _internal_add_cabins(value);
  // @@protoc_insertion_point(field_add:AirfareSearch.Flight.cabins)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Flight::cabins() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.Flight.cabins)
  return _impl_.cabins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Flight::_internal_mutable_cabins() {
  return &_impl_.cabins_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Flight::mutable_cabins() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.Flight.cabins)
  return _internal_mutable_cabins();
}

// -------------------------------------------------------------------

// FlightResult

// repeated .AirfareSearch.Flight flights = 1;
inline int FlightResult::_internal_flights_size() const {
  return _impl_.flights_.size();
}
inline int FlightResult::flights_size() const {
  return _internal_flights_size();
}
inline void FlightResult::clear_flights() {
  _impl_.flights_.Clear();
}
inline ::AirfareSearch::Flight* FlightResult::mutable_flights(int index) {
  // @@protoc_insertion_point(field_mutable:AirfareSearch.FlightResult.flights)
  return _impl_.flights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::Flight >*
FlightResult::mutable_flights() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.FlightResult.flights)
  return &_impl_.flights_;
}
inline const ::AirfareSearch::Flight& FlightResult::_internal_flights(int index) const {
  return _impl_.flights_.Get(index);
}
inline const ::AirfareSearch::Flight& FlightResult::flights(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.FlightResult.flights)
  return _internal_flights(index);
}
inline ::AirfareSearch::Flight* FlightResult::_internal_add_flights() {
  return _impl_.flights_.Add();
}
inline ::AirfareSearch::Flight* FlightResult::add_flights() {
  ::AirfareSearch::Flight* _add = _internal_add_flights();
  // @@protoc_insertion_point(field_add:AirfareSearch.FlightResult.flights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::Flight >&
FlightResult::flights() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.FlightResult.flights)
  return _impl_.flights_;
}

// int32 price = 2;
inline void FlightResult::clear_price() {
  _impl_.price_ = 0;
}
inline int32_t FlightResult::_internal_price() const {
  return _impl_.price_;
}
inline int32_t FlightResult::price() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.FlightResult.price)
  return _internal_price();
}
inline void FlightResult::_internal_set_price(int32_t value) {
  
  _impl_.price_ = value;
}
inline void FlightResult::set_price(int32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.FlightResult.price)
}

// repeated string agencies = 3;
inline int FlightResult::_internal_agencies_size() const {
  return _impl_.agencies_.size();
}
inline int FlightResult::agencies_size() const {
  return _internal_agencies_size();
}
inline void FlightResult::clear_agencies() {
  _impl_.agencies_.Clear();
}
inline std::string* FlightResult::add_agencies() {
  std::string* _s = _internal_add_agencies();
  // @@protoc_insertion_point(field_add_mutable:AirfareSearch.FlightResult.agencies)
  return _s;
}
inline const std::string& FlightResult::_internal_agencies(int index) const {
  return _impl_.agencies_.Get(index);
}
inline const std::string& FlightResult::agencies(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.FlightResult.agencies)
  return _internal_agencies(index);
}
inline std::string* FlightResult::mutable_agencies(int index) {
  // @@protoc_insertion_point(field_mutable:AirfareSearch.FlightResult.agencies)
  return _impl_.agencies_.Mutable(index);
}
inline void FlightResult::set_agencies(int index, const std::string& value) {
  _impl_.agencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::set_agencies(int index, std::string&& value) {
  _impl_.agencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::set_agencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.agencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::set_agencies(int index, const char* value, size_t size) {
  _impl_.agencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AirfareSearch.FlightResult.agencies)
}
inline std::string* FlightResult::_internal_add_agencies() {
  return _impl_.agencies_.Add();
}
inline void FlightResult::add_agencies(const std::string& value) {
  _impl_.agencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::add_agencies(std::string&& value) {
  _impl_.agencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::add_agencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.agencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AirfareSearch.FlightResult.agencies)
}
inline void FlightResult::add_agencies(const char* value, size_t size) {
  _impl_.agencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AirfareSearch.FlightResult.agencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlightResult::agencies() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.FlightResult.agencies)
  return _impl_.agencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlightResult::mutable_agencies() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.FlightResult.agencies)
  return &_impl_.agencies_;
}

// -------------------------------------------------------------------

// SearchResponse

// repeated .AirfareSearch.FlightResult data = 1;
inline int SearchResponse::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int SearchResponse::data_size() const {
  return _internal_data_size();
}
inline void SearchResponse::clear_data() {
  _impl_.data_.Clear();
}
inline ::AirfareSearch::FlightResult* SearchResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchResponse.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::FlightResult >*
SearchResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.SearchResponse.data)
  return &_impl_.data_;
}
inline const ::AirfareSearch::FlightResult& SearchResponse::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::AirfareSearch::FlightResult& SearchResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchResponse.data)
  return _internal_data(index);
}
inline ::AirfareSearch::FlightResult* SearchResponse::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::AirfareSearch::FlightResult* SearchResponse::add_data() {
  ::AirfareSearch::FlightResult* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:AirfareSearch.SearchResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::FlightResult >&
SearchResponse::data() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.SearchResponse.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// SearchRequest

// int32 people = 1;
inline void SearchRequest::clear_people() {
  _impl_.people_ = 0;
}
inline int32_t SearchRequest::_internal_people() const {
  return _impl_.people_;
}
inline int32_t SearchRequest::people() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRequest.people)
  return _internal_people();
}
inline void SearchRequest::_internal_set_people(int32_t value) {
  
  _impl_.people_ = value;
}
inline void SearchRequest::set_people(int32_t value) {
  _internal_set_people(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRequest.people)
}

// int32 maxResults = 2;
inline void SearchRequest::clear_maxresults() {
  _impl_.maxresults_ = 0;
}
inline int32_t SearchRequest::_internal_maxresults() const {
  return _impl_.maxresults_;
}
inline int32_t SearchRequest::maxresults() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRequest.maxResults)
  return _internal_maxresults();
}
inline void SearchRequest::_internal_set_maxresults(int32_t value) {
  
  _impl_.maxresults_ = value;
}
inline void SearchRequest::set_maxresults(int32_t value) {
  _internal_set_maxresults(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRequest.maxResults)
}

// repeated string agencies = 3;
inline int SearchRequest::_internal_agencies_size() const {
  return _impl_.agencies_.size();
}
inline int SearchRequest::agencies_size() const {
  return _internal_agencies_size();
}
inline void SearchRequest::clear_agencies() {
  _impl_.agencies_.Clear();
}
inline std::string* SearchRequest::add_agencies() {
  std::string* _s = _internal_add_agencies();
  // @@protoc_insertion_point(field_add_mutable:AirfareSearch.SearchRequest.agencies)
  return _s;
}
inline const std::string& SearchRequest::_internal_agencies(int index) const {
  return _impl_.agencies_.Get(index);
}
inline const std::string& SearchRequest::agencies(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRequest.agencies)
  return _internal_agencies(index);
}
inline std::string* SearchRequest::mutable_agencies(int index) {
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchRequest.agencies)
  return _impl_.agencies_.Mutable(index);
}
inline void SearchRequest::set_agencies(int index, const std::string& value) {
  _impl_.agencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::set_agencies(int index, std::string&& value) {
  _impl_.agencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::set_agencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.agencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::set_agencies(int index, const char* value, size_t size) {
  _impl_.agencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:AirfareSearch.SearchRequest.agencies)
}
inline std::string* SearchRequest::_internal_add_agencies() {
  return _impl_.agencies_.Add();
}
inline void SearchRequest::add_agencies(const std::string& value) {
  _impl_.agencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::add_agencies(std::string&& value) {
  _impl_.agencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::add_agencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.agencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:AirfareSearch.SearchRequest.agencies)
}
inline void SearchRequest::add_agencies(const char* value, size_t size) {
  _impl_.agencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:AirfareSearch.SearchRequest.agencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SearchRequest::agencies() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.SearchRequest.agencies)
  return _impl_.agencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SearchRequest::mutable_agencies() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.SearchRequest.agencies)
  return &_impl_.agencies_;
}

// repeated .AirfareSearch.SearchRoute routes = 4;
inline int SearchRequest::_internal_routes_size() const {
  return _impl_.routes_.size();
}
inline int SearchRequest::routes_size() const {
  return _internal_routes_size();
}
inline void SearchRequest::clear_routes() {
  _impl_.routes_.Clear();
}
inline ::AirfareSearch::SearchRoute* SearchRequest::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchRequest.routes)
  return _impl_.routes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::SearchRoute >*
SearchRequest::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:AirfareSearch.SearchRequest.routes)
  return &_impl_.routes_;
}
inline const ::AirfareSearch::SearchRoute& SearchRequest::_internal_routes(int index) const {
  return _impl_.routes_.Get(index);
}
inline const ::AirfareSearch::SearchRoute& SearchRequest::routes(int index) const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRequest.routes)
  return _internal_routes(index);
}
inline ::AirfareSearch::SearchRoute* SearchRequest::_internal_add_routes() {
  return _impl_.routes_.Add();
}
inline ::AirfareSearch::SearchRoute* SearchRequest::add_routes() {
  ::AirfareSearch::SearchRoute* _add = _internal_add_routes();
  // @@protoc_insertion_point(field_add:AirfareSearch.SearchRequest.routes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AirfareSearch::SearchRoute >&
SearchRequest::routes() const {
  // @@protoc_insertion_point(field_list:AirfareSearch.SearchRequest.routes)
  return _impl_.routes_;
}

// -------------------------------------------------------------------

// SearchRoute

// int32 id = 1;
inline void SearchRoute::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t SearchRoute::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SearchRoute::id() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRoute.id)
  return _internal_id();
}
inline void SearchRoute::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void SearchRoute::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRoute.id)
}

// .AirfareSearch.City departure = 2;
inline bool SearchRoute::_internal_has_departure() const {
  return this != internal_default_instance() && _impl_.departure_ != nullptr;
}
inline bool SearchRoute::has_departure() const {
  return _internal_has_departure();
}
inline void SearchRoute::clear_departure() {
  if (GetArenaForAllocation() == nullptr && _impl_.departure_ != nullptr) {
    delete _impl_.departure_;
  }
  _impl_.departure_ = nullptr;
}
inline const ::AirfareSearch::City& SearchRoute::_internal_departure() const {
  const ::AirfareSearch::City* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::AirfareSearch::City&>(
      ::AirfareSearch::_City_default_instance_);
}
inline const ::AirfareSearch::City& SearchRoute::departure() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRoute.departure)
  return _internal_departure();
}
inline void SearchRoute::unsafe_arena_set_allocated_departure(
    ::AirfareSearch::City* departure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = departure;
  if (departure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AirfareSearch.SearchRoute.departure)
}
inline ::AirfareSearch::City* SearchRoute::release_departure() {
  
  ::AirfareSearch::City* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AirfareSearch::City* SearchRoute::unsafe_arena_release_departure() {
  // @@protoc_insertion_point(field_release:AirfareSearch.SearchRoute.departure)
  
  ::AirfareSearch::City* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::AirfareSearch::City* SearchRoute::_internal_mutable_departure() {
  
  if (_impl_.departure_ == nullptr) {
    auto* p = CreateMaybeMessage<::AirfareSearch::City>(GetArenaForAllocation());
    _impl_.departure_ = p;
  }
  return _impl_.departure_;
}
inline ::AirfareSearch::City* SearchRoute::mutable_departure() {
  ::AirfareSearch::City* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchRoute.departure)
  return _msg;
}
inline void SearchRoute::set_allocated_departure(::AirfareSearch::City* departure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.departure_;
  }
  if (departure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(departure);
    if (message_arena != submessage_arena) {
      departure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, departure, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.departure_ = departure;
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.SearchRoute.departure)
}

// .AirfareSearch.City arrival = 3;
inline bool SearchRoute::_internal_has_arrival() const {
  return this != internal_default_instance() && _impl_.arrival_ != nullptr;
}
inline bool SearchRoute::has_arrival() const {
  return _internal_has_arrival();
}
inline void SearchRoute::clear_arrival() {
  if (GetArenaForAllocation() == nullptr && _impl_.arrival_ != nullptr) {
    delete _impl_.arrival_;
  }
  _impl_.arrival_ = nullptr;
}
inline const ::AirfareSearch::City& SearchRoute::_internal_arrival() const {
  const ::AirfareSearch::City* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::AirfareSearch::City&>(
      ::AirfareSearch::_City_default_instance_);
}
inline const ::AirfareSearch::City& SearchRoute::arrival() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRoute.arrival)
  return _internal_arrival();
}
inline void SearchRoute::unsafe_arena_set_allocated_arrival(
    ::AirfareSearch::City* arrival) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = arrival;
  if (arrival) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AirfareSearch.SearchRoute.arrival)
}
inline ::AirfareSearch::City* SearchRoute::release_arrival() {
  
  ::AirfareSearch::City* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AirfareSearch::City* SearchRoute::unsafe_arena_release_arrival() {
  // @@protoc_insertion_point(field_release:AirfareSearch.SearchRoute.arrival)
  
  ::AirfareSearch::City* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::AirfareSearch::City* SearchRoute::_internal_mutable_arrival() {
  
  if (_impl_.arrival_ == nullptr) {
    auto* p = CreateMaybeMessage<::AirfareSearch::City>(GetArenaForAllocation());
    _impl_.arrival_ = p;
  }
  return _impl_.arrival_;
}
inline ::AirfareSearch::City* SearchRoute::mutable_arrival() {
  ::AirfareSearch::City* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchRoute.arrival)
  return _msg;
}
inline void SearchRoute::set_allocated_arrival(::AirfareSearch::City* arrival) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arrival_;
  }
  if (arrival) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrival);
    if (message_arena != submessage_arena) {
      arrival = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrival, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arrival_ = arrival;
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.SearchRoute.arrival)
}

// string departureDate = 4;
inline void SearchRoute::clear_departuredate() {
  _impl_.departuredate_.ClearToEmpty();
}
inline const std::string& SearchRoute::departuredate() const {
  // @@protoc_insertion_point(field_get:AirfareSearch.SearchRoute.departureDate)
  return _internal_departuredate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchRoute::set_departuredate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.departuredate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AirfareSearch.SearchRoute.departureDate)
}
inline std::string* SearchRoute::mutable_departuredate() {
  std::string* _s = _internal_mutable_departuredate();
  // @@protoc_insertion_point(field_mutable:AirfareSearch.SearchRoute.departureDate)
  return _s;
}
inline const std::string& SearchRoute::_internal_departuredate() const {
  return _impl_.departuredate_.Get();
}
inline void SearchRoute::_internal_set_departuredate(const std::string& value) {
  
  _impl_.departuredate_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchRoute::_internal_mutable_departuredate() {
  
  return _impl_.departuredate_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchRoute::release_departuredate() {
  // @@protoc_insertion_point(field_release:AirfareSearch.SearchRoute.departureDate)
  return _impl_.departuredate_.Release();
}
inline void SearchRoute::set_allocated_departuredate(std::string* departuredate) {
  if (departuredate != nullptr) {
    
  } else {
    
  }
  _impl_.departuredate_.SetAllocated(departuredate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.departuredate_.IsDefault()) {
    _impl_.departuredate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AirfareSearch.SearchRoute.departureDate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace AirfareSearch

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AirfareSearch::Cabin> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AirfareSearch::Cabin>() {
  return ::AirfareSearch::Cabin_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SearchRequest_2eproto
